##
##	Tend Crops (based on SHOPPING module from The Flat)
##


#
#  part I
#  Pick a target
#

function tend_crops
activity

integer num
object o
object bucket

# Check we've got something to do, otherwise think of something to do

if me.user.user2 = 0	# Are we running or waiting to be primed?
	# Get the object to find
	if_not_exist me.target
		print "Error in crops code|"
		print "Character must point to a target for the first tag|"
		return
	endif

	let me.user.user2 = me.target.tag
endif

# Do we have any water?

find bucket = "bucket_water" in me

if_not_exists bucket

	# No, do we have an empty one?
	find bucket = "bucket" in me
	if_exists bucket
		find_tag o = "target" me.user.user2
		if_exists o
			start_action me does "tend_crops_water" to o
			return
		endif
	else
		# No, find one
		start_action me does "tend_crop_bucket"
		return
	endif
endif


# Now we have a base target number, do a random decision which one to go for
# if we can't find an object with that tag, guess again until we have something
# worth doing

label do_again

	random num between 1 10 # 0 is the water-source
	add num + me.user.user2
	find_tag o = "target" num
	if_exists o

		# Make sure we aren't already at that target
		if o.x = me.x
			if o.y = me.y
				# Guess again
				let o = null
			endif
		endif
	endif

if_not_exist o
	goto do_again
endif

# Chain to the next stage

start_action me does "tend_crops2" to o

end


#
#	part II
#	Go to the desired target
#


function tend_crops2
private

object bucket

if_exists me.target
	# Try to move there
	move_towards me me.target

	if err <> PATH_WAITING
		# Face the same direction as the target object
		set_direction me faces me.target.curdir

		find bucket = "bucket_water" in me
		if_not_exists bucket
			# IT'S GONE!!
			start_action me does "tend_crops3"
			return
		endif

		# pour bucket (on me.target)
		let current = bucket
		call bucket.funcs.ucache
		
		# Wait for 7 turns
		let me.user.user1 = 7

		# Chain to part 3
		start_action me does "tend_crops3"
	endif
endif

end


#
#  part III
#  Wait for a while, then go to part I again
#

function tend_crops3
private

add me.user.user1 - 1
if me.user.user1 <= 0
	let me.user.user1 = 0
	# Chain to the first stage again to repeat the process
	start_action me does "tend_crops"
endif

end

#
#	Get Water
#	Go to the water target
#


function tend_crops_water
private

object bucket
integer nx
integer ny

if_exists me.target
	# Try to move there
	move_towards me me.target

	# not there yet
	if err <> PATH_WAITING
		# Face the same direction as the target object
		set_direction me faces me.target.curdir

		# Bucket..
		find bucket = "bucket" in me
		if_not_exists bucket
			# IT'S GONE!!
			start_action me does "tend_crops3"
			return
		endif

		# Get water from NE
		let nx = me.target.x + 1
		let ny = me.target.y - 1
		get_tile curtile at nx ny

		# Use the bucket
		let current = bucket
		call bucket.funcs.ucache

		# Wait for 7 turns
		let me.user.user1 = 7

		# Chain to part 3
		start_action me does "tend_crops3"
	endif
endif

end




##
##  Strip farming crops
##


function tend_strip_farm
activity
int num
object o

##
##  Start farming
##

let me.user.user1 = 0
let me.user.user2 = 0
let me.user.user3 = 0

# Now pick a row of the strip and go there

if_not_exist me.target
	print "Error in strip farm code|"
	print "Character must point to a target for the first tag|"
	return
endif

# Find upper boundary
let num = me.target.tag + 2
find_tag o = "target" num
if_not_exists o
	print "Error in strip farm - did not find upper boundary object, tag="	
	print num
	printcr
	goto slap_farmer
endif

# Store lower and upper boundaries
let me.user.user1 = me.target.y
let me.user.user3 = o.y
if o.y >= me.target.y
	print "Error in strip farm - upper boundary object below lower boundary!"	
	printcr
	goto slap_farmer
endif

# Pick which of the two strips to patrol this time
random num between 0 1
add num + me.target.tag
find_tag o = "target" num
if_exists o
	start_action me does "find_strip" to o
	return
endif

label slap_farmer
print "Error: strip farming needs three consecutive tags from the start object!"
printcr
print "The farmer hits themselves in their confusion"
printcr

add me.stats.hp - 10
check_hurt me
return
end


##
##  Move to start of strip and begin patrolling
##

function find_strip
private

if_exists me.target
	# Try to move there
	move_towards me me.target

	# code 1 means not ready
	if err <> PATH_WAITING
		# Face the same direction as the target object
		force_direction me faces me.target.curdir

		# Now wander
		start_action me does "wander_strip"
		return
	endif
endif

end

##
##  Move around the strip
##

function wander_strip
private
int r

# Has the counter run out?

if me.user.user2 < 1
	# Pick a random direction
	random r between 0 3
	force_direction me faces r

	# stop them wandering off through a gap
	call crops_checkdir

	# Now pick a random amount to wander, or stare at something
	random r between 3 15
	let me.user.user2 = r
	return
endif

add me.user.user2 - 1

# Move forward.  If they're in front of some crops they won't be able to, but it simulates them examining the crop

# Also, bounce them if they try to leave via the top or bottom of the strip
if me.y >= me.user.user1
	force_direction me faces NORTH
endif
if me.y <= me.user.user3
	force_direction me faces SOUTH
endif

let current = me
call move_forward

end

##
##  Sanity-check the direction change to make sure they're not going to escape
##

function crops_checkdir
int x

if me.curdir = WEST
	let x = me.x - 1
endif
if me.curdir = EAST
	let x = me.x + 1
endif


if_solid x me.y
	# Looks good
	return
endif

# Stop them running out through a gap in the hedge

random x between NORTH SOUTH	# Fortunately these two are consecutive.
force_direction me faces x

end
